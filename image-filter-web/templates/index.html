<!DOCTYPE html>
<html lang="en">
<head>
    <title>Image Color Filter | Elevon</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/static/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;900&display=swap" rel="stylesheet">
    <!-- All custom styles moved to static/style.css for a sleek, modern, and easy-to-use UI. -->
</head>
<body>
    <div class="header-bar">
        <img src="/static/images/elevon_logo.png" alt="Elevon Logo" class="logo-img">
        <h1 class="main-title">Elevon Image Color Filter</h1>
    </div>    <form method="post" enctype="multipart/form-data" class="main-form" onsubmit="return handleFormSubmit(event)">
        <div class="form-section">
            <label class="main-label">Select image file:</label>
            <div class="file-drop-zone" id="fileDropZone">
                <input type="file" name="image" id="image" accept="image/*" required onchange="handleFileSelection()" class="file-input">
                <div class="drop-zone-content">
                    <div class="drop-icon">üìÅ</div>
                    <div class="drop-text">
                        <div class="drop-primary">Drop image here or click to browse</div>
                        <div class="drop-secondary">Supports PNG, JPG, JPEG formats</div>
                    </div>
                </div>
            </div>
            <div id="imagePreview" class="image-preview" style="display: none;">
                <canvas id="previewCanvas"></canvas>
                <div class="preview-info">
                    <span id="imageDimensions"></span>
                    <span id="fileSize"></span>
                </div>
                <div class="preview-toggle">
                    <input type="checkbox" id="realtimePreview" class="preview-checkbox">
                    <label for="realtimePreview" class="preview-label">Show real-time preview</label>
                </div>
            </div>
        </div>
        
        <!-- Add line thickness control -->
        <div class="form-section">
            <label class="main-label">Line Thickness Settings:</label>
            <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem;">
                <label for="lineThickness" style="font-weight: 600;">Thickness (pixels):</label>
                <input type="range" id="lineThickness" name="lineThickness" min="1" max="12" value="4" 
                       style="flex: 1; max-width: 200px;" oninput="updateThicknessDisplay()">
                <span id="thicknessDisplay" style="min-width: 40px; font-weight: 600;">4px</span>
            </div>
            <div style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">
                <strong>Tip:</strong> For 3D printing, use 2-3px for detailed maps, 4-6px for clear visibility. 
                Avoid high values if trails are close together to prevent overlapping.
            </div>
        </div>
        
        <!-- Add trail analysis section -->
        <div class="form-section">
            <label class="main-label">Trail Analysis:</label>
            <div style="margin-bottom: 1rem;">
                <button type="button" class="main-btn" onclick="analyzeTrailSeparation()" 
                        style="padding: 0.7rem 1.5rem; font-size: 1rem; margin-right: 1rem;">
                    Analyze Trail Separation
                </button>
                <span id="analysisResult" style="font-size: 0.9rem; color: #666;"></span>
            </div>
            <div id="separationRecommendation" style="display: none; padding: 1rem; background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 8px; margin-top: 1rem;">
                <div style="color: #0369a1; font-weight: 600; margin-bottom: 0.5rem;">üí° Recommendation:</div>
                <div id="recommendationText" style="color: #0c4a6e; font-size: 0.9rem;"></div>
            </div>
        </div>
        
        <hr class="divider">
        <div class="outputs-container">
        {% for out in range(3) %}
        <div class="output-block" id="output-block-{{out}}">
            <div class="output-header" style="display: flex; align-items: center; justify-content: space-between; gap: 1.2rem; margin-bottom: 1.1rem;">
                <div style="display: flex; align-items: center; gap: 0.7rem; flex: 1 1 auto;">
                    <span class="output-number">Output {{out+1}}</span>
                    <input type="text" name="filename_{{out}}" placeholder="output{{out+1}}.png" class="filename-input" aria-label="Output {{out+1}} filename" style="max-width: 180px;">
                    <select name="format_{{out}}" class="format-select" style="padding: 0.4rem; border-radius: 0.4rem; border: 1px solid #d1d5db;">
                        <option value="png">PNG</option>
                        <option value="svg">SVG (for Inkscape)</option>
                    </select>
                </div>
                <button type="button" class="main-btn download-btn" style="padding: 0.5rem 1.3rem; font-size: 1.05rem; border-radius: 0.6rem; margin-left: 1.2rem;" onclick="downloadSingleOutput('{{ out }}')">Download</button>
            </div>            <div class="color-slots" style="display: flex; flex-direction: column; gap: 0.7rem;">
            {% for slot in range(3) %}
            <div class="color-row" style="display: flex; justify-content: center; align-items: flex-end; gap: 0.7rem; margin-bottom: 0.7rem;">
                <span class="color-slot-label">Color {{slot+1}}:</span>
                <span id="color-label-{{out}}-{{slot}}" class="color-label color-label-preview" style="font-size: 1.05rem; font-weight: 700; min-width: 120px; display: inline-block; border-radius: 0.5rem; padding: 0.3rem 1.1rem; background: #eee; color: #2e3a4a; border: 2px solid #e5e5e5; transition: background 0.2s, border 0.2s; margin-right: 0.7rem;"></span>
                <div style="display: flex; gap: 0.3rem;">
                    <input type="number" name="r_{{out}}_{{slot}}" id="r_{{out}}_{{slot}}" min="0" max="255" placeholder="R" class="color-input" aria-label="Red" data-output="{{out}}" data-slot="{{slot}}" data-channel="r">
                    <input type="number" name="g_{{out}}_{{slot}}" id="g_{{out}}_{{slot}}" min="0" max="255" placeholder="G" class="color-input" aria-label="Green" data-output="{{out}}" data-slot="{{slot}}" data-channel="g">
                    <input type="number" name="b_{{out}}_{{slot}}" id="b_{{out}}_{{slot}}" min="0" max="255" placeholder="B" class="color-input" aria-label="Blue" data-output="{{out}}" data-slot="{{slot}}" data-channel="b">
                </div>
                <input type="number" name="t_{{out}}_{{slot}}" id="t_{{out}}_{{slot}}" min="0" max="442" step="1" placeholder="Tolerance" class="tol-input" aria-label="Tolerance" style="margin-left:0.5rem;" data-output="{{out}}" data-slot="{{slot}}">
                <button type="button" class="apply-btn" style="margin-left: 0.7rem;" data-output="{{out}}" data-slot="{{slot}}">üé® Pick</button>
            </div>
            {% endfor %}
            </div>
            <div id="output-preview-{{out}}" class="output-preview">
                <canvas id="preview-canvas-{{out}}"></canvas>
            </div>
        </div>
        {% endfor %}
        </div>
        <button type="submit" class="main-btn" style="display: block; width: fit-content; margin: 2.2rem auto 0 auto; padding: 1.1rem 2.7rem; font-size: 1.18rem; border-radius: 0.8rem;">Download All Outputs</button>
    </form>    <!-- Modal for picking top color -->
    <div id="apply-modal" class="modal">
        <div class="modal-content" tabindex="-1">
            <span class="close" onclick="closeApplyDialog()">&times;</span>
            <h3 style="margin-top:0; color:#2e3a4a; font-size:1.3rem; font-weight:900;">Pick a Top Color</h3>
            <div id="modal-top-colors"></div>
        </div>
    </div>
      <!-- Processing Overlay -->
    <div id="processing-overlay" class="processing-overlay" style="display: none;">
        <div class="processing-content">
            <div class="processing-spinner"></div>
            <div class="processing-text">Processing Image...</div>
            <div class="processing-details">Extracting centerlines and applying filters</div>
        </div>
    </div>
    
    <!-- Help Panel -->
    <button class="help-toggle" onclick="toggleHelpPanel()" title="Show keyboard shortcuts">?</button>
    <div id="help-panel" class="help-panel">
        <div class="help-title">Keyboard Shortcuts</div>
        <div class="help-shortcut">
            <span class="help-desc">Open file</span>
            <span class="help-key">Ctrl+O</span>
        </div>
        <div class="help-shortcut">
            <span class="help-desc">Process all</span>
            <span class="help-key">Ctrl+Enter</span>
        </div>
        <div class="help-shortcut">
            <span class="help-desc">Toggle preview</span>
            <span class="help-key">R</span>
        </div>
        <div class="help-shortcut">
            <span class="help-desc">Close dialog</span>
            <span class="help-key">Escape</span>
        </div>
        <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e5e7eb; color: #6b7280; font-size: 0.75rem;">
            Drag & drop images, click colors to pick from detected colors, use real-time preview for instant feedback.
            <div style="margin-top: 0.5rem; font-size: 0.7rem; opacity: 0.8;">
                v2.0 Enhanced ‚Ä¢ Advanced centerline extraction ‚Ä¢ Web Worker support
            </div>
        </div>
    </div><script>
    // Helper function to draw thick pixels for centerline tracing
    function drawThickPixel(data, x, y, width, height, thickness) {
        const radius = Math.floor(thickness / 2);
        for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                    // Use circular brush for smoother lines
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= radius) {
                        const index = (ny * width + nx) * 4;
                        data[index] = 0;     // R
                        data[index + 1] = 0; // G
                        data[index + 2] = 0; // B
                        data[index + 3] = 255; // A
                    }
                }
            }
        }
    }    // Enhanced line drawing with overlap detection
    function drawThickPixelWithOverlapDetection(data, x, y, width, height, thickness, overlapMap) {
        const radius = Math.floor(thickness / 2);
        let hasOverlap = false;
        
        for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= radius) {
                        const index = (ny * width + nx) * 4;
                        const coord = `${nx},${ny}`;
                        
                        // Check for overlap with existing trails
                        if (overlapMap.has(coord)) {
                            hasOverlap = true;
                        } else {
                            overlapMap.add(coord);
                        }
                        
                        data[index] = 0;     // R
                        data[index + 1] = 0; // G
                        data[index + 2] = 0; // B
                        data[index + 3] = 255; // A
                    }
                }
            }
        }
        return hasOverlap;
    }    // Advanced Zhang-Suen skeletonization algorithm for better centerlines
    function zhangSuenThinning(trailPixels, width, height) {
        if (trailPixels.size === 0) return new Set();
        
        // Convert to 2D binary array for easier processing
        const binary = Array(height).fill().map(() => Array(width).fill(0));
        for (const coord of trailPixels) {
            const [x, y] = coord.split(',').map(Number);
            if (x >= 0 && x < width && y >= 0 && y < height) {
                binary[y][x] = 1;
            }
        }
        
        let changed = true;
        let iteration = 0;
        const maxIterations = 100; // Prevent infinite loops
        
        while (changed && iteration < maxIterations) {
            changed = false;
            const toDelete = [];
            
            // Two-step process for Zhang-Suen algorithm
            for (let step = 0; step < 2; step++) {
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        if (binary[y][x] === 1) {
                            const neighbors = [
                                binary[y-1][x], binary[y-1][x+1], binary[y][x+1], binary[y+1][x+1],
                                binary[y+1][x], binary[y+1][x-1], binary[y][x-1], binary[y-1][x-1]
                            ];
                            
                            // Count black neighbors
                            const blackNeighbors = neighbors.reduce((sum, val) => sum + val, 0);
                            
                            // Count 0->1 transitions
                            let transitions = 0;
                            for (let i = 0; i < 8; i++) {
                                if (neighbors[i] === 0 && neighbors[(i + 1) % 8] === 1) {
                                    transitions++;
                                }
                            }
                            
                            // Zhang-Suen conditions
                            const cond1 = blackNeighbors >= 2 && blackNeighbors <= 6;
                            const cond2 = transitions === 1;
                            
                            let cond3, cond4;
                            if (step === 0) {
                                cond3 = neighbors[0] * neighbors[2] * neighbors[4] === 0;
                                cond4 = neighbors[2] * neighbors[4] * neighbors[6] === 0;
                            } else {
                                cond3 = neighbors[0] * neighbors[2] * neighbors[6] === 0;
                                cond4 = neighbors[0] * neighbors[4] * neighbors[6] === 0;
                            }
                            
                            if (cond1 && cond2 && cond3 && cond4) {
                                toDelete.push([x, y]);
                                changed = true;
                            }
                        }
                    }
                }
                
                // Apply deletions after checking all pixels
                for (const [x, y] of toDelete) {
                    binary[y][x] = 0;
                }
                toDelete.length = 0;
            }
            iteration++;
        }
        
        // Convert back to Set
        const result = new Set();
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (binary[y][x] === 1) {
                    result.add(`${x},${y}`);
                }
            }
        }
        
        return result;
    }

    // Improved noise reduction and gap filling
    function preprocessTrailPixels(trailPixels, width, height) {
        const processed = new Set();
        
        // Remove isolated pixels (noise reduction)
        for (const coord of trailPixels) {
            const [x, y] = coord.split(',').map(Number);
            let neighbors = 0;
            
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    if (trailPixels.has(`${x + dx},${y + dy}`)) {
                        neighbors++;
                    }
                }
            }
            
            // Keep pixels with at least 1 neighbor (removes isolated pixels)
            if (neighbors > 0) {
                processed.add(coord);
            }
        }
        
        // Gap filling: connect nearby trail segments
        const gapFilled = new Set(processed);
        for (const coord of processed) {
            const [x, y] = coord.split(',').map(Number);
            
            // Look for gaps in 8 directions
            const directions = [
                [0, -2], [2, 0], [0, 2], [-2, 0], // Cardinal directions
                [1, -1], [1, 1], [-1, 1], [-1, -1] // Diagonal directions
            ];
            
            for (const [dx, dy] of directions) {
                const gapX = x + dx;
                const gapY = y + dy;
                const gapCoord = `${gapX},${gapY}`;
                
                if (processed.has(gapCoord)) {
                    // Fill the gap between current pixel and found pixel
                    const midX = x + Math.floor(dx / 2);
                    const midY = y + Math.floor(dy / 2);
                    const midCoord = `${midX},${midY}`;
                    
                    if (midX >= 0 && midX < width && midY >= 0 && midY < height) {
                        gapFilled.add(midCoord);
                    }
                }
            }
        }
        
        return gapFilled;
    }

    // Enhanced line drawing with anti-aliasing
    function drawSmoothThickLine(data, x, y, width, height, thickness, alpha = 1.0) {
        const radius = thickness / 2;
        const radiusSquared = radius * radius;
        
        const minX = Math.max(0, Math.floor(x - radius));
        const maxX = Math.min(width - 1, Math.ceil(x + radius));
        const minY = Math.max(0, Math.floor(y - radius));
        const maxY = Math.min(height - 1, Math.ceil(y + radius));
        
        for (let py = minY; py <= maxY; py++) {
            for (let px = minX; px <= maxX; px++) {
                const dx = px - x;
                const dy = py - y;
                const distSquared = dx * dx + dy * dy;
                
                if (distSquared <= radiusSquared) {
                    // Anti-aliasing: fade out at edges
                    const dist = Math.sqrt(distSquared);
                    let pixelAlpha = alpha;
                    
                    if (dist > radius - 1) {
                        pixelAlpha *= Math.max(0, radius - dist);
                    }
                    
                    const index = (py * width + px) * 4;
                    const currentAlpha = data[index + 3] / 255;
                    const newAlpha = Math.min(1, currentAlpha + pixelAlpha);
                    
                    // Blend with existing pixel
                    data[index] = Math.floor(data[index] * (1 - pixelAlpha)); // R
                    data[index + 1] = Math.floor(data[index + 1] * (1 - pixelAlpha)); // G
                    data[index + 2] = Math.floor(data[index + 2] * (1 - pixelAlpha)); // B
                    data[index + 3] = Math.floor(newAlpha * 255); // A
                }
            }
        }
    }

    // Create centerline trace from detected trail pixels
    function createCenterlineTrace(trailPixels, width, height) {
        if (trailPixels.size === 0) return new Set();
        
        // Step 1: Preprocess to remove noise and fill gaps
        const preprocessed = preprocessTrailPixels(trailPixels, width, height);
        
        // Step 2: Apply Zhang-Suen thinning for professional skeletonization
        const thinned = zhangSuenThinning(preprocessed, width, height);
        
        // Step 3: If result is too sparse, fall back to simpler method
        if (thinned.size < Math.max(10, trailPixels.size * 0.05)) {
            console.warn('Zhang-Suen thinning resulted in sparse output, using fallback method');
            return createCenterlineTraceFallback(preprocessed, width, height);
        }
        
        return thinned;
    }

    // Fallback centerline method (your original algorithm, improved)
    function createCenterlineTraceFallback(trailPixels, width, height) {
        const centerlinePixels = new Set();
        
        for (const coord of trailPixels) {
            const [x, y] = coord.split(',').map(Number);
            
            // Count neighbors
            let neighborCount = 0;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    if (trailPixels.has(`${x + dx},${y + dy}`)) {
                        neighborCount++;
                    }
                }
            }
            
            // Include important pixels: endpoints, line pixels, and junctions
            if (neighborCount <= 2 || neighborCount >= 4) {
                centerlinePixels.add(coord);
            }
        }
        
        // Ensure connectivity
        if (centerlinePixels.size < trailPixels.size * 0.1) {
            for (const coord of trailPixels) {
                const [x, y] = coord.split(',').map(Number);
                if ((x + y) % 3 === 0) { // Sample every 3rd pixel
                    centerlinePixels.add(coord);
                }
            }
        }
        
        return centerlinePixels;
    }

    // Check if a pixel is essential for connectivity
    function checkConnectivity(x, y, trailPixels, width, height) {
        // Simple connectivity check - if removing this pixel would disconnect neighbors
        const neighbors = [];
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0) continue;
                const neighborCoord = `${x + dx},${y + dy}`;
                if (trailPixels.has(neighborCoord)) {
                    neighbors.push({x: x + dx, y: y + dy});
                }
            }
        }
        
        // If we have 3+ neighbors, this might be a junction
        return neighbors.length >= 3;
    }

        let topColors = [];
    let applyTarget = {out: 0, slot: 0};
    let currentImage = null;
    
    // Processing overlay functions
    function showProcessingOverlay(message = 'Processing Image...', details = 'Extracting centerlines and applying filters') {
        const overlay = document.getElementById('processing-overlay');
        const text = overlay.querySelector('.processing-text');
        const detailsElement = overlay.querySelector('.processing-details');
        text.textContent = message;
        detailsElement.textContent = details;
        overlay.style.display = 'flex';
    }
    
    function hideProcessingOverlay() {
        document.getElementById('processing-overlay').style.display = 'none';
    }
    
    // Web Worker support for better performance
    let imageWorker = null;
    let workerTasks = new Map();
    
    function initWebWorker() {
        if (!window.Worker) return false;
        
        try {
            imageWorker = new Worker('/static/image-worker.js');
            imageWorker.onmessage = function(e) {
                const { type, taskId, progress, message, imageData, error } = e.data;
                  switch (type) {
                    case 'progress':
                        updateProcessingProgress(taskId, progress, message);
                        break;
                    case 'complete':
                        handleWorkerComplete(taskId, imageData);
                        break;
                    case 'warning':
                        showOverlapWarning(message);
                        break;
                    case 'error':
                        handleWorkerError(taskId, error);
                        break;
                }
            };
            
            imageWorker.onerror = function(error) {
                console.warn('Web Worker error:', error);
                imageWorker = null;
            };
            
            return true;
        } catch (error) {
            console.warn('Web Worker not supported:', error);
            return false;
        }
    }
    
    function updateProcessingProgress(taskId, progress, message) {
        const overlay = document.getElementById('processing-overlay');
        const progressElement = overlay.querySelector('.processing-details');
        if (progressElement) {
            progressElement.textContent = `${message} (${progress}%)`;
        }
    }
    
    function handleWorkerComplete(taskId, imageData) {
        const task = workerTasks.get(taskId);
        if (!task) return;
        
        const { canvas, filename, callback } = task;
        const ctx = canvas.getContext('2d');
        const processedImageData = new ImageData(
            new Uint8ClampedArray(imageData.data),
            imageData.width,
            imageData.height
        );
        ctx.putImageData(processedImageData, 0, 0);
        
        // Download the result
        const link = document.createElement('a');
        link.download = filename.endsWith('.png') ? filename : filename + '.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
        
        workerTasks.delete(taskId);
        if (callback) callback();
    }
    
    function handleWorkerError(taskId, error) {
        console.error('Worker processing error:', error);
        const task = workerTasks.get(taskId);
        if (task && task.fallbackCallback) {
            task.fallbackCallback();
        }
        workerTasks.delete(taskId);
    }
    
    function showOverlapWarning(message) {
        // Create a non-intrusive warning notification
        const warningDiv = document.createElement('div');
        warningDiv.style.cssText = `
            position: fixed; top: 20px; right: 20px; z-index: 10000;
            background: #fef3c7; border: 1px solid #f59e0b; border-radius: 8px;
            padding: 12px 16px; max-width: 300px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            font-family: Inter, sans-serif; font-size: 14px; color: #92400e;
        `;
        warningDiv.innerHTML = `
            <div style="display: flex; align-items: center; gap: 8px;">
                <span style="font-size: 16px;">‚ö†Ô∏è</span>
                <div>
                    <strong>Trail Overlap Warning</strong><br>
                    ${message}
                </div>
                <button onclick="this.parentElement.parentElement.remove()" 
                        style="background: none; border: none; cursor: pointer; margin-left: auto; font-size: 18px; color: #92400e;">√ó</button>
            </div>
        `;
        document.body.appendChild(warningDiv);
        
        // Auto-remove after 8 seconds
        setTimeout(() => {
            if (warningDiv.parentElement) {
                warningDiv.remove();
            }
        }, 8000);
    }
    
    function processWithWorker(img, colorTols, filename, callback) {
        if (!imageWorker) {
            // Fallback to main thread processing
            return processAndDownloadOutput(img, colorTols, filename, callback);
        }
        
        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        const imageData = ctx.getImageData(0, 0, img.width, img.height);
        
        const taskId = Date.now() + Math.random();
        workerTasks.set(taskId, {
            canvas,
            filename,
            callback,
            fallbackCallback: () => processAndDownloadOutput(img, colorTols, filename, callback)
        });
          const lineThickness = parseInt(document.getElementById('lineThickness')?.value || '4', 10);
        
        imageWorker.postMessage({
            imageData,
            colorTolerance: colorTols,
            taskId,
            lineThickness
        });
    }

    // Help panel toggle
    function toggleHelpPanel() {
        const panel = document.getElementById('help-panel');
        if (panel.style.display === 'none' || !panel.style.display) {
            panel.style.display = 'block';
            // Auto-hide after 10 seconds
            setTimeout(() => {
                if (panel.style.display === 'block') {
                    panel.style.display = 'none';
                }
            }, 10000);
        } else {
            panel.style.display = 'none';
        }
    }

    // Keyboard shortcuts for better UX
    document.addEventListener('keydown', function(e) {
        // Ctrl/Cmd + O: Open file dialog
        if ((e.ctrlKey || e.metaKey) && e.key === 'o') {
            e.preventDefault();
            document.getElementById('image').click();
        }
        
        // Ctrl/Cmd + Enter: Process all outputs
        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
            e.preventDefault();
            const form = document.querySelector('.main-form');
            if (form) {
                form.dispatchEvent(new Event('submit'));
            }
        }
        
        // Escape: Close modal
        if (e.key === 'Escape') {
            const modal = document.getElementById('apply-modal');
            if (modal && modal.style.display === 'flex') {
                closeApplyDialog();
            }
            const overlay = document.getElementById('processing-overlay');
            if (overlay && overlay.style.display === 'flex') {
                // Don't allow canceling processing - could corrupt state
                // Just ignore escape during processing
            }
        }
        
        // R key: Toggle real-time preview
        if (e.key === 'r' && !e.ctrlKey && !e.metaKey && !e.altKey) {
            const activeElement = document.activeElement;
            // Only if not typing in an input field
            if (activeElement.tagName !== 'INPUT' && activeElement.tagName !== 'TEXTAREA') {
                e.preventDefault();
                const checkbox = document.getElementById('realtimePreview');
                if (checkbox) {
                    checkbox.checked = !checkbox.checked;
                    updateRealtimePreview();
                }
            }
        }
    });

    // Enhanced file handling with drag & drop
    function setupDragAndDrop() {
        const dropZone = document.getElementById('fileDropZone');
        const fileInput = document.getElementById('image');
        
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
        });
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, highlight, false);
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, unhighlight, false);
        });
        
        function highlight() {
            dropZone.classList.add('dragover');
        }
        
        function unhighlight() {
            dropZone.classList.remove('dragover');
        }
        
        dropZone.addEventListener('drop', handleDrop, false);
        
        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            
            if (files.length > 0) {
                fileInput.files = files;
                handleFileSelection();
            }
        }
    }
    
    // Enhanced file selection handler
    function handleFileSelection() {
        const fileInput = document.getElementById('image');
        if (!fileInput.files.length) return;
        
        const file = fileInput.files[0];
        
        // Validate file type
        if (!file.type.match(/image\/(png|jpg|jpeg)/i)) {
            alert('Please select a PNG, JPG, or JPEG image file.');
            fileInput.value = '';
            return;
        }
        
        // Validate file size (max 50MB)
        const maxSize = 50 * 1024 * 1024;
        if (file.size > maxSize) {
            alert('Image file is too large. Please select a file smaller than 50MB.');
            fileInput.value = '';
            return;
        }
        
        showImagePreview(file);
        extractTopColorsFrontend();
    }
    
    // Show image preview with dimensions and file size
    function showImagePreview(file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            const img = new Image();
            img.onload = function() {
                currentImage = img;
                
                const canvas = document.getElementById('previewCanvas');
                const ctx = canvas.getContext('2d');
                
                // Calculate preview dimensions (max 400px width)
                const maxWidth = 400;
                const ratio = Math.min(maxWidth / img.width, maxWidth / img.height);
                canvas.width = img.width * ratio;
                canvas.height = img.height * ratio;
                
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                
                // Update preview info
                document.getElementById('imageDimensions').textContent = `${img.width} √ó ${img.height} pixels`;
                document.getElementById('fileSize').textContent = formatFileSize(file.size);
                
                // Show preview container
                document.getElementById('imagePreview').style.display = 'block';
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }
    
    // Format file size for display
    function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    
    // Real-time preview functionality
    function updateRealtimePreview() {
        const checkbox = document.getElementById('realtimePreview');
        if (!checkbox.checked || !currentImage) return;
        
        // Update all output previews
        for (let out = 0; out < 3; out++) {
            updateOutputPreview(out);
        }
    }
    
    // Update individual output preview
    function updateOutputPreview(outputIndex) {
        if (!currentImage) return;
        
        const canvas = document.getElementById(`preview-canvas-${outputIndex}`);
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        
        // Get colors and tolerances for this output
        const colorTols = [];
        for (let slot = 0; slot < 3; slot++) {
            const r = document.getElementById(`r_${outputIndex}_${slot}`).value;
            const g = document.getElementById(`g_${outputIndex}_${slot}`).value;
            const b = document.getElementById(`b_${outputIndex}_${slot}`).value;
            const t = document.getElementById(`t_${outputIndex}_${slot}`).value;
            if (r !== '' && g !== '' && b !== '' && t !== '') {
                colorTols.push({r: +r, g: +g, b: +b, tol: +t});
            }
        }
        
        if (colorTols.length === 0) {
            document.getElementById(`output-preview-${outputIndex}`).classList.remove('active');
            return;
        }
        
        // Set canvas size (smaller for preview)
        const previewScale = 0.3;
        canvas.width = currentImage.width * previewScale;
        canvas.height = currentImage.height * previewScale;
        
        // Process image (simplified for real-time preview)
        ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Simple color filtering for preview (no centerline processing)
        for (let i = 0; i < data.length; i += 4) {
            if (data[i+3] === 0) {
                data[i] = 255; data[i+1] = 255; data[i+2] = 255; data[i+3] = 255;
                continue;
            }
            
            let keep = false;
            for (const c of colorTols) {
                const dr = data[i] - c.r;
                const dg = data[i+1] - c.g;
                const db = data[i+2] - c.b;
                const dist = Math.sqrt(dr*dr + dg*dg + db*db);
                if (dist <= c.tol) {
                    keep = true;
                    break;
                }
            }
            
            if (!keep) {
                data[i] = 255; data[i+1] = 255; data[i+2] = 255;
            } else {
                data[i] = 0; data[i+1] = 0; data[i+2] = 0;
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
        document.getElementById(`output-preview-${outputIndex}`).classList.add('active');
    }

function setTopColors(colors) {
    topColors = colors;
}

function areColorsSimilar(color1, color2, threshold = 30) { // Decreased threshold from 50 to 30 for more distinct colors
    // Calculate Euclidean distance between two colors
    const dr = color1[0] - color2[0];
    const dg = color1[1] - color2[1];
    const db = color1[2] - color2[2];
    return Math.sqrt(dr*dr + dg*dg + db*db) < threshold;
}

function extractTopColorsFrontend() {
    const fileInput = document.getElementById('image');
    if (!fileInput.files.length) return;
    const file = fileInput.files[0];
    const reader = new FileReader();
    reader.onload = function(e) {
        const img = new window.Image();
        img.onload = function() {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            const data = ctx.getImageData(0, 0, img.width, img.height).data;
            const colorCounts = {};
            for (let i = 0; i < data.length; i += 4) {
                if (data[i+3] === 0) continue; // Skip transparent pixels
                const key = data[i] + ',' + data[i+1] + ',' + data[i+2];
                colorCounts[key] = (colorCounts[key] || 0) + 1;
            }
              // Helper function to check if a color is solid/saturated enough
            function isSolidColor(color) {
                const [r, g, b] = color;
                
                // Skip very light colors (too close to white)
                if (r > 240 && g > 240 && b > 240) return false;
                
                // Calculate saturation (simplified HSV saturation)
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const saturation = max === 0 ? 0 : (max - min) / max;
                
                // Skip colors with very low saturation (too gray/washed out)
                // Exception: allow very dark colors (like black) even if low saturation
                const brightness = max / 255;
                if (saturation < 0.5 && brightness > 0.1) return false; // More strict: require more vivid color
                
                return true;
            }

            const sortedColors = Object.entries(colorCounts)
                .sort((a, b) => b[1] - a[1])
                .map(([k, v]) => k.split(',').map(Number))
                .filter(color => isSolidColor(color)); // Only consider solid colors

            const distinctTopColors = [];
            const distinctnessThreshold = 60; // Increased threshold for better distinctness

            for (const color of sortedColors) {
                if (distinctTopColors.length >= 5) break; // Limit to exactly 5 colors

                let isSimilarToExisting = false;
                for (const existingColor of distinctTopColors) {
                    if (areColorsSimilar(color, existingColor, distinctnessThreshold)) {
                        isSimilarToExisting = true;
                        break;
                    }
                }
                if (!isSimilarToExisting) {
                    distinctTopColors.push(color);
                }
            }
            setTopColors(distinctTopColors);
        };
        img.src = e.target.result;
    };
    reader.readAsDataURL(file);
}
function openApplyDialog(out, slot) {
    applyTarget = {out, slot};
    const modal = document.getElementById('apply-modal');
    const modalColors = document.getElementById('modal-top-colors');
    modalColors.innerHTML = '';
    if (!topColors.length) {
        modalColors.innerHTML = '<i>No top colors detected. Please select an image first.</i>';
    } else {
        topColors.forEach(function(color, idx) {
            const colorRow = document.createElement('div');
            colorRow.style.display = 'flex';
            colorRow.style.alignItems = 'center';
            colorRow.style.marginBottom = '8px';
            colorRow.style.justifyContent = 'space-between';
            const swatch = document.createElement('span');
            swatch.className = 'color-swatch modern-color-swatch';
            swatch.style.background = 'rgb(' + color[0] + ',' + color[1] + ',' + color[2] + ')';
            swatch.style.marginRight = '10px';
            const rgbLabel = document.createElement('span');
            rgbLabel.textContent = 'RGB(' + color[0] + ', ' + color[1] + ', ' + color[2] + ')';
            rgbLabel.style.fontWeight = '500';
            rgbLabel.style.marginRight = '10px';
            const keepBtn = document.createElement('button');
            keepBtn.className = 'apply-btn modern-apply-btn';
            keepBtn.style.background = 'rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',0.85)';
            keepBtn.style.color = '#fff';
            keepBtn.style.margin = '5px 0 5px 8px';
            keepBtn.textContent = 'Keep';
            keepBtn.type = 'button';
            keepBtn.onclick = function() {
                applyColorToEntry(color, out, slot);
                highlightOutputBlock(out);
                closeApplyDialog();
            };
            colorRow.appendChild(swatch);
            colorRow.appendChild(rgbLabel);
            colorRow.appendChild(keepBtn);
            modalColors.appendChild(colorRow);
        });
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'apply-btn modern-apply-btn';
        cancelBtn.style.background = '#888';
        cancelBtn.style.margin = '5px';
        cancelBtn.textContent = 'Cancel';
        cancelBtn.onclick = closeApplyDialog;
        modalColors.appendChild(cancelBtn);
    }
    modal.style.display = 'flex';
    setTimeout(function() {
        document.querySelector('.modal-content').focus();
    }, 100);
}
function closeApplyDialog() {
    document.getElementById('apply-modal').style.display = 'none';
}
function setColorInputsAndPreview(out, slot, r, g, b) {
    // Set the input values and trigger input events for live update
    const rInput = document.getElementById('r_' + out + '_' + slot);
    const gInput = document.getElementById('g_' + out + '_' + slot);
    const bInput = document.getElementById('b_' + out + '_' + slot);
    if (rInput && gInput && bInput) {
        rInput.value = r;
        gInput.value = g;
        bInput.value = b;
        // Manually trigger input events so listeners update the preview
        rInput.dispatchEvent(new Event('input', { bubbles: true }));
        gInput.dispatchEvent(new Event('input', { bubbles: true }));
        bInput.dispatchEvent(new Event('input', { bubbles: true }));
    }
}
function applyColorToEntry(color, outputIdx, colorIdx) {
    setColorInputsAndPreview(outputIdx, colorIdx, color[0], color[1], color[2]);
    highlightOutputBlock(outputIdx);
    closeApplyDialog();
}

function updateColorPreview(out, slot) {
    const rInput = document.getElementById('r_' + out + '_' + slot);
    const gInput = document.getElementById('g_' + out + '_' + slot);
    const bInput = document.getElementById('b_' + out + '_' + slot);
    const colorLabel = document.getElementById('color-label-' + out + '-' + slot);

    if (colorLabel) {
        colorLabel.style.display = 'none'; // Hide the dedicated color label span
    }

    // Ensure inputs exist before trying to read their values or style them
    if (!rInput || !gInput || !bInput) {
        // console.error('RGB input elements not found for out:' + out + ', slot:' + slot);
        return;
    }

    const rValStr = rInput.value;
    const gValStr = gInput.value;
    const bValStr = bInput.value;

    if (rValStr.trim() !== '' && gValStr.trim() !== '' && bValStr.trim() !== '') {
        const r = parseInt(rValStr);
        const g = parseInt(gValStr);
        const b = parseInt(bValStr);

        if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
            const rNorm = Math.max(0, Math.min(255, r));
            const gNorm = Math.max(0, Math.min(255, g));
            const bNorm = Math.max(0, Math.min(255, b));

            const bgColor = 'rgb(' + rNorm + ',' + gNorm + ',' + bNorm + ')';
            const luminance = (0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm) / 255;
            const textColor = luminance > 0.6 ? '#222' : '#fff';
            const borderColor = luminance > 0.6 ? '#aaa' : '#555';

            [rInput, gInput, bInput].forEach(input => {
                if (input) {
                    input.style.background = bgColor;
                    input.style.color = textColor;
                    input.style.border = '1px solid ' + borderColor;
                }
            });
        } else {
            // Handle cases where input is not a valid number after parsing
            [rInput, gInput, bInput].forEach(input => {
                if (input) {
                    input.style.background = '';
                    input.style.color = '';
                    input.style.border = ''; // Reverts to CSS defined border
                }
            });
        }
    } else {
        // Reset styles if any input is empty
        [rInput, gInput, bInput].forEach(input => {
            if (input) {
                input.style.background = '';
                input.style.color = '';
                input.style.border = ''; // Reverts to CSS defined border
            }
        });
    }
}

// Enhanced event handling
function updateColorPreview(out, slot) {
    const rInput = document.getElementById('r_' + out + '_' + slot);
    const gInput = document.getElementById('g_' + out + '_' + slot);
    const bInput = document.getElementById('b_' + out + '_' + slot);
    const colorLabel = document.getElementById('color-label-' + out + '-' + slot);

    if (colorLabel) {
        colorLabel.style.display = 'none';
    }

    if (!rInput || !gInput || !bInput) {
        return;
    }

    const rValStr = rInput.value;
    const gValStr = gInput.value;
    const bValStr = bInput.value;

    if (rValStr.trim() !== '' && gValStr.trim() !== '' && bValStr.trim() !== '') {
        const r = parseInt(rValStr);
        const g = parseInt(gValStr);
        const b = parseInt(bValStr);

        if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
            const rNorm = Math.max(0, Math.min(255, r));
            const gNorm = Math.max(0, Math.min(255, g));
            const bNorm = Math.max(0, Math.min(255, b));

            const bgColor = 'rgb(' + rNorm + ',' + gNorm + ',' + bNorm + ')';
            const luminance = (0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm) / 255;
            const textColor = luminance > 0.6 ? '#222' : '#fff';
            const borderColor = luminance > 0.6 ? '#aaa' : '#555';

            [rInput, gInput, bInput].forEach(input => {
                if (input) {
                    input.style.background = bgColor;
                    input.style.color = textColor;
                    input.style.border = '1px solid ' + borderColor;
                }
            });
        } else {
            [rInput, gInput, bInput].forEach(input => {
                if (input) {
                    input.style.background = '';
                    input.style.color = '';
                    input.style.border = '';
                }
            });
        }
    } else {
        [rInput, gInput, bInput].forEach(input => {
            if (input) {
                input.style.background = '';
                input.style.color = '';
                input.style.border = '';
            }
        });
    }
    
    // Update real-time preview if enabled
    setTimeout(() => updateRealtimePreview(), 100);
}

// On page load, initialize everything
window.addEventListener('DOMContentLoaded', function() {
    setupDragAndDrop();
    
    // Initialize Web Worker for better performance
    const workerSupported = initWebWorker();
    if (workerSupported) {
        console.log('Web Worker initialized for better performance on large images');
    }
    
    // Setup color input event listeners
    for (let out = 0; out < 3; out++) {
        for (let slot = 0; slot < 3; slot++) {
            updateColorPreview(out, slot);
            ['r','g','b'].forEach(function(ch) {
                const el = document.getElementById(ch + '_' + out + '_' + slot);
                if (el) {
                    el.addEventListener('input', function() { 
                        updateColorPreview(out, slot);
                    });
                }
            });
            
            // Setup tolerance input listener
            const tolInput = document.getElementById('t_' + out + '_' + slot);
            if (tolInput) {
                tolInput.addEventListener('input', function() {
                    setTimeout(() => updateRealtimePreview(), 100);
                });
            }
        }
    }
    
    // Setup real-time preview checkbox
    const previewCheckbox = document.getElementById('realtimePreview');
    if (previewCheckbox) {
        previewCheckbox.addEventListener('change', updateRealtimePreview);
    }
    
    // Setup apply buttons using event delegation
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('apply-btn')) {
            const out = e.target.getAttribute('data-output');
            const slot = e.target.getAttribute('data-slot');
            if (out !== null && slot !== null) {
                openApplyDialog(out, slot);
            }
        }
    });
});
document.addEventListener('input', function(e) {
    var id = e.target.id;
    var rgbMatch = id && id.match(/^([rgb])_(\d+)_(\d+)$/);
    if (rgbMatch) {
        var out = rgbMatch[2];
        var slot = rgbMatch[3];
        updateColorPreview(out, slot);
    }
});
function highlightOutputBlock(outIdx) {
    for (let i = 0; i < 3; i++) {
        const block = document.getElementById('output-block-' + i);
        if (block) {
            if (i === outIdx) {
                block.classList.add('selected');
            } else {
                block.classList.remove('selected');
            }
        }
    }
}
function handleFormSubmit(e) {
    // Prevent backend upload, do all processing in browser
    e.preventDefault();
    const fileInput = document.getElementById('image');
    if (!fileInput.files.length) {
        alert('Please select an image.');
        return false;
    }
    
    showProcessingOverlay('Processing All Outputs...', 'This may take a moment for large images');
    
    const file = fileInput.files[0];
    const reader = new FileReader();
    reader.onload = function(ev) {
        const img = new window.Image();
        img.onload = function() {
            let processedCount = 0;
            const totalOutputs = 3;
            
            for (let out = 0; out < 3; out++) {
                const filename = document.querySelector(`[name=filename_${out}]`).value.trim() || `output${out+1}.png`;
                let colorTols = [];
                for (let slot = 0; slot < 3; slot++) {
                    const r = document.getElementById(`r_${out}_${slot}`).value;
                    const g = document.getElementById(`g_${out}_${slot}`).value;
                    const b = document.getElementById(`b_${out}_${slot}`).value;
                    const t = document.getElementById(`t_${out}_${slot}`).value;
                    if (r !== '' && g !== '' && b !== '' && t !== '') {
                        colorTols.push({r: +r, g: +g, b: +b, tol: +t});
                    }
                }
                  if (colorTols.length > 0) {
                    // Use setTimeout to allow UI to update
                    setTimeout(() => {
                        // Use Web Worker for better performance on large images
                        const useWorker = img.width * img.height > 1000000; // Use worker for images > 1MP
                        if (useWorker && imageWorker) {
                            processWithWorker(img, colorTols, filename, () => {
                                processedCount++;
                                if (processedCount === totalOutputs || out === 2) {
                                    setTimeout(() => hideProcessingOverlay(), 500);
                                }
                            });
                        } else {
                            processAndDownloadOutput(img, colorTols, filename, () => {
                                processedCount++;
                                if (processedCount === totalOutputs || out === 2) {
                                    setTimeout(() => hideProcessingOverlay(), 500);
                                }
                            });
                        }
                    }, out * 100); // Stagger processing slightly
                }
            }
            
            // Hide overlay if no outputs to process
            if (processedCount === 0) {
                setTimeout(() => hideProcessingOverlay(), 500);
            }
        };
        img.src = ev.target.result;
    };
    reader.readAsDataURL(file);
    return false;
}

function processAndDownloadOutput(img, colorTols, filename, callback) {
    // Create canvas and process
    const canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0);
    const imageData = ctx.getImageData(0, 0, img.width, img.height);
    const data = imageData.data;
    
    // First pass: identify trail pixels
    const trailPixels = new Set();
    for (let i = 0; i < data.length; i += 4) {
        // If the original pixel is transparent, make it white and fully opaque
        if (data[i+3] === 0) {
            data[i] = 255; data[i+1] = 255; data[i+2] = 255; data[i+3] = 255;
            continue;
        }
        const originalR = data[i];
        const originalG = data[i+1];
        const originalB = data[i+2];
        let keep = false;
        for (const c of colorTols) {
            const dr = originalR - c.r;
            const dg = originalG - c.g;
            const db = originalB - c.b;
            const dist = Math.sqrt(dr*dr + dg*dg + db*db);
            if (dist <= c.tol) {
                keep = true;
                break;
            }
        }
        if (keep) {
            const pixelIndex = Math.floor(i / 4);
            const x = pixelIndex % img.width;
            const y = Math.floor(pixelIndex / img.width);
            trailPixels.add(`${x},${y}`);
        }
        // Initially set all pixels to white
        data[i] = 255; data[i+1] = 255; data[i+2] = 255; data[i+3] = 255;
    }

    // Create centerline trace with thick uniform lines
    const processedTrailPixels = createCenterlineTrace(trailPixels, img.width, img.height);
    
    // Draw thick lines on the processed pixels
    for (const coordStr of processedTrailPixels) {
        const [x, y] = coordStr.split(',').map(Number);
        drawThickPixel(data, x, y, img.width, img.height, 4); // 4 pixel thick lines
    }
    
    ctx.putImageData(imageData, 0, 0);
    // Download result
    const link = document.createElement('a');
    link.download = filename.endsWith('.png') ? filename : filename + '.png';
    link.href = canvas.toDataURL('image/png');
    link.click();
    
    if (callback) callback();
}
function downloadSingleOutput(out) {
    const fileInput = document.getElementById('image');
    if (!fileInput.files.length) {
        alert('Please select an image.');
        return;
    }
    
    showProcessingOverlay(`Processing Output ${parseInt(out) + 1}...`, 'Extracting centerlines and applying filters');
    
    const file = fileInput.files[0];
    const reader = new FileReader();
    reader.onload = function(ev) {
        const img = new window.Image();
        img.onload = function() {
            const filename = document.querySelector(`[name=filename_${out}]`).value.trim() || `output${parseInt(out)+1}.png`;
            let colorTols = [];
            for (let slot = 0; slot < 3; slot++) {
                const r = document.getElementById(`r_${out}_${slot}`).value;
                const g = document.getElementById(`g_${out}_${slot}`).value;
                const b = document.getElementById(`b_${out}_${slot}`).value;
                const t = document.getElementById(`t_${out}_${slot}`).value;
                if (r !== '' && g !== '' && b !== '' && t !== '') {
                    colorTols.push({r: +r, g: +g, b: +b, tol: +t});
                }
            }
              if (colorTols.length > 0) {
                setTimeout(() => {
                    // Use Web Worker for better performance on large images
                    const useWorker = img.width * img.height > 1000000; // Use worker for images > 1MP
                    if (useWorker && imageWorker) {
                        processWithWorker(img, colorTols, filename, () => {
                            setTimeout(() => hideProcessingOverlay(), 500);
                        });
                    } else {
                        processAndDownloadOutput(img, colorTols, filename, () => {
                            setTimeout(() => hideProcessingOverlay(), 500);
                        });
                    }
                }, 100);
            } else {
                hideProcessingOverlay();
                alert('Please enter at least one color for this output.');
            }
        };
        img.src = ev.target.result;
    };
    reader.readAsDataURL(file);
}
    // Trail separation analysis for 3D printing optimization
    function analyzeTrailSeparation() {
        if (!currentImage) {
            document.getElementById('analysisResult').textContent = 'Please load an image first.';
            return;
        }
        
        document.getElementById('analysisResult').textContent = 'Analyzing...';
        
        // Get current color tolerances for analysis
        const colorTols = [];
        for (let out = 0; out < 3; out++) {
            for (let slot = 0; slot < 3; slot++) {
                const r = parseInt(document.getElementById(`r_${out}_${slot}`)?.value || '0');
                const g = parseInt(document.getElementById(`g_${out}_${slot}`)?.value || '0');
                const b = parseInt(document.getElementById(`b_${out}_${slot}`)?.value || '0');
                const t = parseInt(document.getElementById(`t_${out}_${slot}`)?.value || '0');
                
                if (r || g || b || t) {
                    colorTols.push({r, g, b, tol: t});
                }
            }
        }
        
        if (colorTols.length === 0) {
            document.getElementById('analysisResult').textContent = 'Please set at least one color filter first.';
            return;
        }
        
        // Create canvas for analysis
        const canvas = document.createElement('canvas');
        canvas.width = currentImage.width;
        canvas.height = currentImage.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(currentImage, 0, 0);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Identify trail pixels
        const trailPixels = new Set();
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            for (const color of colorTols) {
                const dr = r - color.r;
                const dg = g - color.g;
                const db = b - color.b;
                const dist = Math.sqrt(dr*dr + dg*dg + db*db);
                
                if (dist <= color.tol) {
                    const pixelIndex = Math.floor(i / 4);
                    const x = pixelIndex % canvas.width;
                    const y = Math.floor(pixelIndex / canvas.width);
                    trailPixels.add(`${x},${y}`);
                    break;
                }
            }
        }
        
        // Analyze minimum distances between trail segments
        const separationData = calculateTrailSeparations(trailPixels, canvas.width, canvas.height);
        displaySeparationRecommendation(separationData);
    }
    
    function calculateTrailSeparations(trailPixels, width, height) {
        const pixelArray = Array.from(trailPixels).map(coord => {
            const [x, y] = coord.split(',').map(Number);
            return {x, y};
        });
        
        if (pixelArray.length < 100) {
            return { minDistance: 999, avgDistance: 999, denseClusters: 0 };
        }
        
        // Sample analysis for performance (analyze every 10th pixel)
        const sampleSize = Math.min(500, Math.floor(pixelArray.length / 10));
        const sampledPixels = [];
        
        for (let i = 0; i < sampleSize; i++) {
            const randomIndex = Math.floor(Math.random() * pixelArray.length);
            sampledPixels.push(pixelArray[randomIndex]);
        }
        
        let minDistance = 999;
        let totalDistance = 0;
        let denseClusters = 0;
        let validPairs = 0;
        
        for (let i = 0; i < sampledPixels.length; i++) {
            let nearestDistance = 999;
            let nearbyCount = 0;
            
            for (let j = 0; j < sampledPixels.length; j++) {
                if (i === j) continue;
                
                const dx = sampledPixels[i].x - sampledPixels[j].x;
                const dy = sampledPixels[i].y - sampledPixels[j].y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < nearestDistance && distance > 1) { // Ignore adjacent pixels
                    nearestDistance = distance;
                }
                
                if (distance < 15) { // Count nearby pixels
                    nearbyCount++;
                }
            }
            
            if (nearestDistance < 999) {
                minDistance = Math.min(minDistance, nearestDistance);
                totalDistance += nearestDistance;
                validPairs++;
                
                if (nearbyCount > 20) { // Dense cluster detection
                    denseClusters++;
                }
            }
        }
        
        return {
            minDistance: minDistance,
            avgDistance: validPairs > 0 ? totalDistance / validPairs : 999,
            denseClusters: denseClusters,
            totalTrailPixels: trailPixels.size
        };
    }
    
    function displaySeparationRecommendation(data) {
        const resultSpan = document.getElementById('analysisResult');
        const recommendationDiv = document.getElementById('separationRecommendation');
        const recommendationText = document.getElementById('recommendationText');
        
        const currentThickness = parseInt(document.getElementById('lineThickness')?.value || '4');
        
        let analysis = `Found ${data.totalTrailPixels} trail pixels. `;
        let recommendation = '';
        
        if (data.minDistance < currentThickness * 2) {
            analysis += `‚ö†Ô∏è Close trails detected (min: ${data.minDistance.toFixed(1)}px).`;
            recommendation = `Your current thickness (${currentThickness}px) may cause overlapping. ` +
                           `Recommended thickness: ${Math.max(1, Math.floor(data.minDistance / 2))}px or lower. ` +
                           `For 3D printing, consider reducing thickness or increasing image resolution.`;
        } else if (data.minDistance < currentThickness * 3) {
            analysis += `‚ö° Moderate trail separation (min: ${data.minDistance.toFixed(1)}px).`;
            recommendation = `Current thickness (${currentThickness}px) should work but watch for overlaps. ` +
                           `For safer 3D printing, consider ${Math.floor(data.minDistance / 3)}px thickness.`;
        } else {
            analysis += `‚úÖ Good trail separation (min: ${data.minDistance.toFixed(1)}px).`;
            recommendation = `Current thickness (${currentThickness}px) looks safe. You can increase thickness up to ` +
                           `${Math.floor(data.minDistance / 2)}px for better visibility without overlapping.`;
        }
        
        if (data.denseClusters > data.totalTrailPixels * 0.1) {
            recommendation += ` Note: Dense trail clusters detected - extra care needed in those areas.`;
        }
        
        resultSpan.textContent = analysis;
        recommendationText.textContent = recommendation;
        recommendationDiv.style.display = 'block';
    }
    
    // SVG generation for Inkscape workflow
    function generateSVG(trailPixels, width, height, lineThickness, filename) {
        const svgNS = "http://www.w3.org/2000/svg";
        
        // Create SVG document
        let svgContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="${svgNS}" viewBox="0 0 ${width} ${height}" width="${width}" height="${height}">
  <defs>
    <style>
      .trail-path { 
        fill: none; 
        stroke: #000000; 
        stroke-width: ${lineThickness}; 
        stroke-linecap: round; 
        stroke-linejoin: round; 
      }
    </style>
  </defs>
  <rect width="100%" height="100%" fill="white"/>
`;
        
        // Convert trail pixels to path data
        const paths = createSVGPaths(trailPixels, width, height);
        
        for (const pathData of paths) {
            svgContent += `  <path class="trail-path" d="${pathData}"/>\n`;
        }
        
        svgContent += '</svg>';
        
        // Download SVG
        const blob = new Blob([svgContent], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename.endsWith('.svg') ? filename : filename.replace(/\.[^.]+$/, '.svg');
        link.click();
        URL.revokeObjectURL(url);
    }
    
    function createSVGPaths(trailPixels, width, height) {
        // Group connected pixels into paths
        const visited = new Set();
        const paths = [];
        
        for (const coordStr of trailPixels) {
            if (visited.has(coordStr)) continue;
            
            const [startX, startY] = coordStr.split(',').map(Number);
            const path = tracePath(startX, startY, trailPixels, visited);
            
            if (path.length > 1) {
                // Convert path to SVG path data
                let pathData = `M ${path[0].x} ${path[0].y}`;
                
                if (path.length === 2) {
                    pathData += ` L ${path[1].x} ${path[1].y}`;
                } else if (path.length > 2) {
                    // Use smooth curves for longer paths
                    for (let i = 1; i < path.length; i++) {
                        if (i === 1) {
                            pathData += ` L ${path[i].x} ${path[i].y}`;
                        } else {
                            // Simple line-to for now, could be enhanced with curves
                            pathData += ` L ${path[i].x} ${path[i].y}`;
                        }
                    }
                }
                
                paths.push(pathData);
            }
        }
        
        return paths;
    }
    
    function tracePath(startX, startY, trailPixels, visited) {
        const path = [{x: startX, y: startY}];
        visited.add(`${startX},${startY}`);
        
        let currentX = startX;
        let currentY = startY;
        
        // Follow connected pixels
        while (true) {
            let found = false;
            
            // Check 8-connected neighbors
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    
                    const nextX = currentX + dx;
                    const nextY = currentY + dy;
                    const nextCoord = `${nextX},${nextY}`;
                    
                    if (trailPixels.has(nextCoord) && !visited.has(nextCoord)) {
                        path.push({x: nextX, y: nextY});
                        visited.add(nextCoord);
                        currentX = nextX;
                        currentY = nextY;
                        found = true;
                        break;
                    }
                }
                if (found) break;
            }
            
            if (!found) break;
        }
        
        return path;
    }
    </script>
</body>
</html>