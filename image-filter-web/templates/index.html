<!DOCTYPE html>
<html lang="en">
<head>
    <title>Image Color Filter | Elevon</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/static/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;900&display=swap" rel="stylesheet">
    <!-- All custom styles moved to static/style.css for a sleek, modern, and easy-to-use UI. -->
</head>
<body>
    <div class="header-bar">
        <img src="/static/images/elevon_logo.png" alt="Elevon Logo" class="logo-img">
        <h1 class="main-title">Elevon Image Color Filter</h1>
    </div>
    <form method="post" enctype="multipart/form-data" class="main-form" onsubmit="return handleFormSubmit(event)">
        <div class="form-section">
            <label class="main-label">Select PNG image:</label>
            <input type="file" name="image" id="image" accept="image/png" required onchange="extractTopColorsFrontend()" class="file-input">
        </div>
        <hr class="divider">
        <div class="outputs-container">
        {% for out in range(3) %}
        <div class="output-block" id="output-block-{{out}}">
            <div class="output-header" style="display: flex; align-items: center; justify-content: space-between; gap: 1.2rem; margin-bottom: 1.1rem;">
                <div style="display: flex; align-items: center; gap: 0.7rem; flex: 1 1 auto;">
                    <span class="output-number">Output {{out+1}}</span>
                    <input type="text" name="filename_{{out}}" placeholder="output{{out+1}}.png" class="filename-input" aria-label="Output {{out+1}} filename" style="max-width: 180px;">
                </div>
                <button type="button" class="main-btn download-btn" style="padding: 0.5rem 1.3rem; font-size: 1.05rem; border-radius: 0.6rem; margin-left: 1.2rem;" onclick="downloadSingleOutput('{{ out }}')">Download</button>
            </div>
            <div class="color-slots" style="display: flex; flex-direction: column; gap: 0.7rem;">
            {% for slot in range(3) %}
            <div class="color-row" style="display: flex; justify-content: center; align-items: flex-end; gap: 0.7rem; margin-bottom: 0.7rem;">
                <span class="color-slot-label">Color {{slot+1}}:</span>
                <span id="color-label-{{out}}-{{slot}}" class="color-label color-label-preview" style="font-size: 1.05rem; font-weight: 700; min-width: 120px; display: inline-block; border-radius: 0.5rem; padding: 0.3rem 1.1rem; background: #eee; color: #2e3a4a; border: 2px solid #e5e5e5; transition: background 0.2s, border 0.2s; margin-right: 0.7rem;"></span>
                <div style="display: flex; gap: 0.3rem;">
                    <input type="number" name="r_{{out}}_{{slot}}" id="r_{{out}}_{{slot}}" min="0" max="255" placeholder="R" class="color-input" aria-label="Red" oninput="updateColorPreview({{out}},{{slot}})">
                    <input type="number" name="g_{{out}}_{{slot}}" id="g_{{out}}_{{slot}}" min="0" max="255" placeholder="G" class="color-input" aria-label="Green" oninput="updateColorPreview({{out}},{{slot}})">
                    <input type="number" name="b_{{out}}_{{slot}}" id="b_{{out}}_{{slot}}" min="0" max="255" placeholder="B" class="color-input" aria-label="Blue" oninput="updateColorPreview({{out}},{{slot}})">
                </div>
                <input type="number" name="t_{{out}}_{{slot}}" id="t_{{out}}_{{slot}}" min="0" max="442" step="1" placeholder="Tolerance" class="tol-input" aria-label="Tolerance" style="margin-left:0.5rem;">
                <button type="button" class="apply-btn" style="margin-left: 0.7rem;" onclick="openApplyDialog('{{ out }}', '{{ slot }}')">ðŸŽ¨ Pick</button>
            </div>
            {% endfor %}
            </div>
        </div>
        {% endfor %}
        </div>
        <button type="submit" class="main-btn" style="display: block; width: fit-content; margin: 2.2rem auto 0 auto; padding: 1.1rem 2.7rem; font-size: 1.18rem; border-radius: 0.8rem;">Download All Outputs</button>
    </form>
    <!-- Modal for picking top color -->
    <div id="apply-modal" class="modal">
        <div class="modal-content" tabindex="-1">
            <span class="close" onclick="closeApplyDialog()">&times;</span>
            <h3 style="margin-top:0; color:#2e3a4a; font-size:1.3rem; font-weight:900;">Pick a Top Color</h3>
            <div id="modal-top-colors"></div>
        </div>
    </div>    <script>
    // Helper function to draw thick pixels for centerline tracing
    function drawThickPixel(data, x, y, width, height, thickness) {
        const radius = Math.floor(thickness / 2);
        for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                    // Use circular brush for smoother lines
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= radius) {
                        const index = (ny * width + nx) * 4;
                        data[index] = 0;     // R
                        data[index + 1] = 0; // G
                        data[index + 2] = 0; // B
                        data[index + 3] = 255; // A
                    }
                }
            }
        }
    }

    // Create centerline trace from detected trail pixels
    function createCenterlineTrace(trailPixels, width, height) {
        if (trailPixels.size === 0) return new Set();
        
        // Convert to array for processing
        const pixelArray = Array.from(trailPixels).map(coord => {
            const [x, y] = coord.split(',').map(Number);
            return {x, y};
        });
        
        // Simple centerline extraction using thinning
        const centerlinePixels = new Set();
        
        // For each trail pixel, check if it's part of the centerline
        for (const pixel of pixelArray) {
            const {x, y} = pixel;
            
            // Count neighbors (8-connectivity)
            let neighborCount = 0;
            const neighbors = [];
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const neighborCoord = `${x + dx},${y + dy}`;
                    if (trailPixels.has(neighborCoord)) {
                        neighborCount++;
                        neighbors.push({x: x + dx, y: y + dy});
                    }
                }
            }
            
            // Include pixel if it's:
            // 1. An endpoint (1 neighbor)
            // 2. Part of a continuous line (2 neighbors)
            // 3. A junction point (3+ neighbors)
            // 4. An isolated pixel (0 neighbors)
            if (neighborCount <= 2 || neighborCount >= 3) {
                centerlinePixels.add(`${x},${y}`);
            }
            // For pixels with many neighbors, apply additional thinning
            else if (neighborCount >= 4) {
                // Check if this pixel is essential for connectivity
                const isEssential = checkConnectivity(x, y, trailPixels, width, height);
                if (isEssential) {
                    centerlinePixels.add(`${x},${y}`);
                }
            }
        }
        
        // If centerline is too sparse, include more pixels
        if (centerlinePixels.size < trailPixels.size * 0.1) {
            // Fall back to including more trail pixels
            for (const pixel of pixelArray) {
                const {x, y} = pixel;
                // Include every nth pixel to ensure connectivity
                if ((x + y) % 2 === 0) {
                    centerlinePixels.add(`${x},${y}`);
                }
            }
        }
        
        return centerlinePixels;
    }

    // Check if a pixel is essential for connectivity
    function checkConnectivity(x, y, trailPixels, width, height) {
        // Simple connectivity check - if removing this pixel would disconnect neighbors
        const neighbors = [];
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0) continue;
                const neighborCoord = `${x + dx},${y + dy}`;
                if (trailPixels.has(neighborCoord)) {
                    neighbors.push({x: x + dx, y: y + dy});
                }
            }
        }
        
        // If we have 3+ neighbors, this might be a junction
        return neighbors.length >= 3;
    }

    let topColors = [];
let applyTarget = {out: 0, slot: 0};
function setTopColors(colors) {
    topColors = colors;
}

function areColorsSimilar(color1, color2, threshold = 30) { // Decreased threshold from 50 to 30 for more distinct colors
    // Calculate Euclidean distance between two colors
    const dr = color1[0] - color2[0];
    const dg = color1[1] - color2[1];
    const db = color1[2] - color2[2];
    return Math.sqrt(dr*dr + dg*dg + db*db) < threshold;
}

function extractTopColorsFrontend() {
    const fileInput = document.getElementById('image');
    if (!fileInput.files.length) return;
    const file = fileInput.files[0];
    const reader = new FileReader();
    reader.onload = function(e) {
        const img = new window.Image();
        img.onload = function() {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            const data = ctx.getImageData(0, 0, img.width, img.height).data;
            const colorCounts = {};
            for (let i = 0; i < data.length; i += 4) {
                if (data[i+3] === 0) continue; // Skip transparent pixels
                const key = data[i] + ',' + data[i+1] + ',' + data[i+2];
                colorCounts[key] = (colorCounts[key] || 0) + 1;
            }
              // Helper function to check if a color is solid/saturated enough
            function isSolidColor(color) {
                const [r, g, b] = color;
                
                // Skip very light colors (too close to white)
                if (r > 240 && g > 240 && b > 240) return false;
                
                // Calculate saturation (simplified HSV saturation)
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const saturation = max === 0 ? 0 : (max - min) / max;
                
                // Skip colors with very low saturation (too gray/washed out)
                // Exception: allow very dark colors (like black) even if low saturation
                const brightness = max / 255;
                if (saturation < 0.5 && brightness > 0.1) return false; // More strict: require more vivid color
                
                return true;
            }

            const sortedColors = Object.entries(colorCounts)
                .sort((a, b) => b[1] - a[1])
                .map(([k, v]) => k.split(',').map(Number))
                .filter(color => isSolidColor(color)); // Only consider solid colors

            const distinctTopColors = [];
            const distinctnessThreshold = 60; // Increased threshold for better distinctness

            for (const color of sortedColors) {
                if (distinctTopColors.length >= 5) break; // Limit to exactly 5 colors

                let isSimilarToExisting = false;
                for (const existingColor of distinctTopColors) {
                    if (areColorsSimilar(color, existingColor, distinctnessThreshold)) {
                        isSimilarToExisting = true;
                        break;
                    }
                }
                if (!isSimilarToExisting) {
                    distinctTopColors.push(color);
                }
            }
            setTopColors(distinctTopColors);
        };
        img.src = e.target.result;
    };
    reader.readAsDataURL(file);
}
function openApplyDialog(out, slot) {
    applyTarget = {out, slot};
    const modal = document.getElementById('apply-modal');
    const modalColors = document.getElementById('modal-top-colors');
    modalColors.innerHTML = '';
    if (!topColors.length) {
        modalColors.innerHTML = '<i>No top colors detected. Please select an image first.</i>';
    } else {
        topColors.forEach(function(color, idx) {
            const colorRow = document.createElement('div');
            colorRow.style.display = 'flex';
            colorRow.style.alignItems = 'center';
            colorRow.style.marginBottom = '8px';
            colorRow.style.justifyContent = 'space-between';
            const swatch = document.createElement('span');
            swatch.className = 'color-swatch modern-color-swatch';
            swatch.style.background = 'rgb(' + color[0] + ',' + color[1] + ',' + color[2] + ')';
            swatch.style.marginRight = '10px';
            const rgbLabel = document.createElement('span');
            rgbLabel.textContent = 'RGB(' + color[0] + ', ' + color[1] + ', ' + color[2] + ')';
            rgbLabel.style.fontWeight = '500';
            rgbLabel.style.marginRight = '10px';
            const keepBtn = document.createElement('button');
            keepBtn.className = 'apply-btn modern-apply-btn';
            keepBtn.style.background = 'rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',0.85)';
            keepBtn.style.color = '#fff';
            keepBtn.style.margin = '5px 0 5px 8px';
            keepBtn.textContent = 'Keep';
            keepBtn.type = 'button';
            keepBtn.onclick = function() {
                applyColorToEntry(color, out, slot);
                highlightOutputBlock(out);
                closeApplyDialog();
            };
            colorRow.appendChild(swatch);
            colorRow.appendChild(rgbLabel);
            colorRow.appendChild(keepBtn);
            modalColors.appendChild(colorRow);
        });
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'apply-btn modern-apply-btn';
        cancelBtn.style.background = '#888';
        cancelBtn.style.margin = '5px';
        cancelBtn.textContent = 'Cancel';
        cancelBtn.onclick = closeApplyDialog;
        modalColors.appendChild(cancelBtn);
    }
    modal.style.display = 'flex';
    setTimeout(function() {
        document.querySelector('.modal-content').focus();
    }, 100);
}
function closeApplyDialog() {
    document.getElementById('apply-modal').style.display = 'none';
}
function setColorInputsAndPreview(out, slot, r, g, b) {
    // Set the input values and trigger input events for live update
    const rInput = document.getElementById('r_' + out + '_' + slot);
    const gInput = document.getElementById('g_' + out + '_' + slot);
    const bInput = document.getElementById('b_' + out + '_' + slot);
    if (rInput && gInput && bInput) {
        rInput.value = r;
        gInput.value = g;
        bInput.value = b;
        // Manually trigger input events so listeners update the preview
        rInput.dispatchEvent(new Event('input', { bubbles: true }));
        gInput.dispatchEvent(new Event('input', { bubbles: true }));
        bInput.dispatchEvent(new Event('input', { bubbles: true }));
    }
}
function applyColorToEntry(color, outputIdx, colorIdx) {
    setColorInputsAndPreview(outputIdx, colorIdx, color[0], color[1], color[2]);
    highlightOutputBlock(outputIdx);
    closeApplyDialog();
}

function updateColorPreview(out, slot) {
    const rInput = document.getElementById('r_' + out + '_' + slot);
    const gInput = document.getElementById('g_' + out + '_' + slot);
    const bInput = document.getElementById('b_' + out + '_' + slot);
    const colorLabel = document.getElementById('color-label-' + out + '-' + slot);

    if (colorLabel) {
        colorLabel.style.display = 'none'; // Hide the dedicated color label span
    }

    // Ensure inputs exist before trying to read their values or style them
    if (!rInput || !gInput || !bInput) {
        // console.error('RGB input elements not found for out:' + out + ', slot:' + slot);
        return;
    }

    const rValStr = rInput.value;
    const gValStr = gInput.value;
    const bValStr = bInput.value;

    if (rValStr.trim() !== '' && gValStr.trim() !== '' && bValStr.trim() !== '') {
        const r = parseInt(rValStr);
        const g = parseInt(gValStr);
        const b = parseInt(bValStr);

        if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
            const rNorm = Math.max(0, Math.min(255, r));
            const gNorm = Math.max(0, Math.min(255, g));
            const bNorm = Math.max(0, Math.min(255, b));

            const bgColor = 'rgb(' + rNorm + ',' + gNorm + ',' + bNorm + ')';
            const luminance = (0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm) / 255;
            const textColor = luminance > 0.6 ? '#222' : '#fff';
            const borderColor = luminance > 0.6 ? '#aaa' : '#555';

            [rInput, gInput, bInput].forEach(input => {
                if (input) {
                    input.style.background = bgColor;
                    input.style.color = textColor;
                    input.style.border = '1px solid ' + borderColor;
                }
            });
        } else {
            // Handle cases where input is not a valid number after parsing
            [rInput, gInput, bInput].forEach(input => {
                if (input) {
                    input.style.background = '';
                    input.style.color = '';
                    input.style.border = ''; // Reverts to CSS defined border
                }
            });
        }
    } else {
        // Reset styles if any input is empty
        [rInput, gInput, bInput].forEach(input => {
            if (input) {
                input.style.background = '';
                input.style.color = '';
                input.style.border = ''; // Reverts to CSS defined border
            }
        });
    }
}

// On page load, initialize all color previews to match any prefilled values
window.addEventListener('DOMContentLoaded', function() {
    for (let out = 0; out < 3; out++) {
        for (let slot = 0; slot < 3; slot++) {
            updateColorPreview(out, slot);
            // Add listeners for all R/G/B fields
            ['r','g','b'].forEach(function(ch) {
                var el = document.getElementById(ch + '_' + out + '_' + slot);
                if (el) {
                    el.addEventListener('input', function() { updateColorPreview(out, slot); });
                }
            });
        }
    }
});
document.addEventListener('input', function(e) {
    var id = e.target.id;
    var rgbMatch = id && id.match(/^([rgb])_(\d+)_(\d+)$/);
    if (rgbMatch) {
        var out = rgbMatch[2];
        var slot = rgbMatch[3];
        updateColorPreview(out, slot);
    }
});
function highlightOutputBlock(outIdx) {
    for (let i = 0; i < 3; i++) {
        const block = document.getElementById('output-block-' + i);
        if (block) {
            if (i === outIdx) {
                block.classList.add('selected');
            } else {
                block.classList.remove('selected');
            }
        }
    }
}
function handleFormSubmit(e) {
    // Prevent backend upload, do all processing in browser
    e.preventDefault();
    const fileInput = document.getElementById('image');
    if (!fileInput.files.length) {
        alert('Please select an image.');
        return false;
    }
    const file = fileInput.files[0];
    const reader = new FileReader();
    reader.onload = function(ev) {
        const img = new window.Image();
        img.onload = function() {
            for (let out = 0; out < 3; out++) {
                const filename = document.querySelector(`[name=filename_${out}]`).value.trim() || `output${out+1}.png`;
                let colorTols = [];
                for (let slot = 0; slot < 3; slot++) {
                    const r = document.getElementById(`r_${out}_${slot}`).value;
                    const g = document.getElementById(`g_${out}_${slot}`).value;
                    const b = document.getElementById(`b_${out}_${slot}`).value;
                    const t = document.getElementById(`t_${out}_${slot}`).value;
                    if (r !== '' && g !== '' && b !== '' && t !== '') {
                        colorTols.push({r: +r, g: +g, b: +b, tol: +t});
                    }
                }                if (colorTols.length > 0) {
                    // Create canvas and process
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, img.width, img.height);
                    const data = imageData.data;
                    
                    // First pass: identify trail pixels
                    const trailPixels = new Set();
                    for (let i = 0; i < data.length; i += 4) {
                        // If the original pixel is transparent, make it white and fully opaque
                        if (data[i+3] === 0) {
                            data[i] = 255; data[i+1] = 255; data[i+2] = 255; data[i+3] = 255;
                            continue;
                        }
                        const originalR = data[i];
                        const originalG = data[i+1];
                        const originalB = data[i+2];
                        let keep = false;
                        for (const c of colorTols) {
                            const dr = originalR - c.r;
                            const dg = originalG - c.g;
                            const db = originalB - c.b;
                            const dist = Math.sqrt(dr*dr + dg*dg + db*db);
                            if (dist <= c.tol) {
                                keep = true;
                                break;
                            }
                        }
                        if (keep) {
                            const pixelIndex = Math.floor(i / 4);
                            const x = pixelIndex % img.width;
                            const y = Math.floor(pixelIndex / img.width);
                            trailPixels.add(`${x},${y}`);
                        }
                        // Initially set all pixels to white
                        data[i] = 255; data[i+1] = 255; data[i+2] = 255; data[i+3] = 255;
                    }

                    // Create centerline trace with thick uniform lines
                    const processedTrailPixels = createCenterlineTrace(trailPixels, img.width, img.height);
                    
                    // Draw thick lines on the processed pixels
                    for (const coordStr of processedTrailPixels) {
                        const [x, y] = coordStr.split(',').map(Number);
                        drawThickPixel(data, x, y, img.width, img.height, 4); // 4 pixel thick lines
                    }
                    
                    ctx.putImageData(imageData, 0, 0);
                    // Download result
                    const link = document.createElement('a');
                    link.download = filename.endsWith('.png') ? filename : filename + '.png';
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                }
            }
        };
        img.src = ev.target.result;
    };
    reader.readAsDataURL(file);
    return false;
}
function downloadSingleOutput(out) {
    const fileInput = document.getElementById('image');
    if (!fileInput.files.length) {
        alert('Please select an image.');
        return;
    }
    const file = fileInput.files[0];
    const reader = new FileReader();
    reader.onload = function(ev) {
        const img = new window.Image();
        img.onload = function() {
            const filename = document.querySelector(`[name=filename_${out}]`).value.trim() || `output${out+1}.png`;
            let colorTols = [];
            for (let slot = 0; slot < 3; slot++) {
                const r = document.getElementById(`r_${out}_${slot}`).value;
                const g = document.getElementById(`g_${out}_${slot}`).value;
                const b = document.getElementById(`b_${out}_${slot}`).value;
                const t = document.getElementById(`t_${out}_${slot}`).value;
                if (r !== '' && g !== '' && b !== '' && t !== '') {
                    colorTols.push({r: +r, g: +g, b: +b, tol: +t});
                }
            }            if (colorTols.length > 0) {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                const imageData = ctx.getImageData(0, 0, img.width, img.height);
                const data = imageData.data;
                
                // First pass: identify trail pixels
                const trailPixels = new Set();
                for (let i = 0; i < data.length; i += 4) {
                    // If the original pixel is transparent, make it white and fully opaque
                    if (data[i+3] === 0) {
                        data[i] = 255; data[i+1] = 255; data[i+2] = 255; data[i+3] = 255;
                        continue;
                    }
                    const originalR = data[i];
                    const originalG = data[i+1];
                    const originalB = data[i+2];
                    let keep = false;
                    for (const c of colorTols) {
                        const dr = originalR - c.r;
                        const dg = originalG - c.g;
                        const db = originalB - c.b;
                        const dist = Math.sqrt(dr*dr + dg*dg + db*db);
                        if (dist <= c.tol) {
                            keep = true;
                            break;
                        }
                    }
                    if (keep) {
                        const pixelIndex = Math.floor(i / 4);
                        const x = pixelIndex % img.width;
                        const y = Math.floor(pixelIndex / img.width);
                        trailPixels.add(`${x},${y}`);
                    }
                    // Initially set all pixels to white
                    data[i] = 255; data[i+1] = 255; data[i+2] = 255; data[i+3] = 255;
                }

                // Create centerline trace with thick uniform lines
                const processedTrailPixels = createCenterlineTrace(trailPixels, img.width, img.height);
                
                // Draw thick lines on the processed pixels
                for (const coordStr of processedTrailPixels) {
                    const [x, y] = coordStr.split(',').map(Number);
                    drawThickPixel(data, x, y, img.width, img.height, 4); // 4 pixel thick lines
                }
                
                ctx.putImageData(imageData, 0, 0);
                const link = document.createElement('a');
                link.download = filename.endsWith('.png') ? filename : filename + '.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
            }else {
                alert('Please enter at least one color for this output.');
            }
        };
        img.src = ev.target.result;
    };
    reader.readAsDataURL(file);
}
    </script>
</body>
</html>